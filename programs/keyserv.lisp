;;;; Copyright (c) Frank James 2015 <frank.a.james@gmail.com>
;;;; This code is licensed under the MIT license.

;;; Autogenerated from frpc/gen/xfiles/key_prot.x at 2015-6-2 16:41:16 

;;;
;;; This file defines a keyserver (as defined in key_prot.x) to distribute secret/public keys for use with 
;;; AUTH-DES authentication flavour. 
;;; Essentially this is an RPC interface to the functionality in des.lisp.
;;; 

(defpackage #:keyserv
  (:use #:cl #:frpc)
  (:export #:call-null
           #:call-set
           #:call-encrypt
           #:call-decrypt
           #:call-gen
           #:call-get))

(in-package #:keyserv)


(defxenum keystatus 
  (:success 0) 
  (:nosecret 1) 
  (:unknown 2)
  (:error 3))

(define-condition key-error (error)
  ((stat :initarg :stat :reader key-error-stat))
  (:report (lambda (c stream)
             (format stream "KEY-ERROR: ~A" (key-error-stat c)))))

(defconstant +hex-key-bytes+ 48)

(defxtype* des-block () (:array :octet 8))
(defxtype* keybuf () (:varray* :octet +hex-key-bytes+))
(defxtype* netnamestr () :string)

(defxtype* cryptkeyarg () 
  (:list netnamestr des-block)) ;; remotename deskey

(defxunion cryptkeyres (keystatus) 
  (:success des-block)
  (otherwise :void))

(defconstant +max-gids+ 16)

(defxtype* unixcred ()
  (:plist :uid :uint32
          :gid :uint32 
          :gids (:varray :uint32 +max-gids+)))

(defxunion getcredres (keystatus) 
  (:success unixcred)
  (otherwise :void))

(defprogram key-prog 100029)

;; ------------------------------

(defun handle-null (void)
  (declare (ignore void))
  nil)

(defrpc call-null 0 :void :void
  (:program key-prog 1)
  (:handler #'handle-null))

;; ---------------------------------

(defun auth-or-fail ()
  "The caller MUST be authenticated using AUTH-UNIX (or AUTH-SHORT)."
  (unless (equalp *rpc-remote-host* #(127 0 0 1))
    (error 'rpc-auth-error))
  (let ((creds (get-unix-creds)))
    (if creds
        creds
        (error 'rpc-auth-error))))

(defvar *keylist* nil
  "List of (unix-creds netname secret-key public-key) for each known host.")

(defvar *keyfile-path* (merge-pathnames "keyprot.dat")
  "Pathname of where the key database file is located.")

(defun write-keylist ()
  "Write the keylist to this file whenever we add new credentials"
  (with-open-file (f *keyfile-path* 
                     :direction :output
                     :if-exists :supersede)
    (pprint *keylist* f)))

(defun read-keylist ()
  "Read the initial keylist from the file on first access to an empty *keylist*."
  (with-open-file (f *keyfile-path* 
                     :direction :input
                     :if-does-not-exist :create)
    (read f nil nil)))

(defun add-key-entry (creds netname secret-key)
  (declare (type frpc::auth-unix creds)
           (type string netname)
           (type vector secret-key))
  ;; convert the array version of the key into a bignum
  (push 
   (let ((secret 
          (do ((i 0 (1+ i))
               (n 0))
              ((= i (length secret-key)) n)
            (setf n (+ (ash n 8) (aref secret-key i))))))
     (list creds 
           netname 
           secret 
           (frpc:des-public secret)))
   *keylist*)
  (write-keylist))

(defun find-key-entry (netname)
  (unless *keylist* (read-keylist))
  (find-if (lambda (entry)
             (let ((name (second entry)))
               (string-equal name netname)))
           *keylist*))

;; ----------------------------------------

(defun handle-set (key)
  (let ((creds (auth-or-fail)))
    (add-key-entry creds (rpc-auth-principal) key)
    :success))

(defrpc call-set 1 keybuf keystatus 
  (:program key-prog 1)
  (:arg-transformer (key) key)
  (:transformer (res)
    (if (eq res :success) 
        nil
        (error 'key-error :stat res)))
  (:documentation "This is my secret key, store it for me.")
  (:handler #'handle-set))

;; ---------------------------------

(defun handle-encrypt (arg)
  (auth-or-fail)
  (destructuring-bind (netname key) arg
    ;; find the entries for the client (caller) and server (named by netname)
    (let ((server-entry (find-key-entry netname))
          (client-entry (find-key-entry (rpc-auth-principal))))
      (if (and client-entry server-entry)
          (destructuring-bind (c n server-secret server-public) server-entry 
            (declare (ignore c n server-secret))
            (destructuring-bind (c n client-secret client-public) client-entry
              (declare (ignore c n client-public))
              ;; compute the common key of the client and the entry
              (let ((common (frpc::dh-common-key client-secret server-public)))
                (make-xunion :success 
                             (frpc::dh-encrypt-conversation-key common 
                                                                (concatenate '(vector (unsigned-byte 8))
                                                                             key))))))
          (make-xunion :unknown nil)))))

(defrpc call-encrypt 2 cryptkeyarg cryptkeyres 
  (:program key-prog 1)
  (:arg-transformer (netname key)
    (list netname key))
  (:transformer (res)
    (if (eq (xunion-tag res) :success)
        (xunion-val res)
        (error 'key-error :stat (xunion-tag res))))
  (:documentation "I want to talk to X, encrypt a conversation key for me.")
  (:handler #'handle-encrypt))

;; ---------------------------------

(defun handle-decrypt (arg)
  (auth-or-fail)
  (destructuring-bind (netname key) arg
    ;; find the entries for the server (caller) and client (named by netname)
    (let ((client-entry (find-key-entry netname))
          (server-entry (find-key-entry (rpc-auth-principal))))
      (if (and client-entry server-entry)
          (destructuring-bind (c n server-secret server-public) server-entry 
            (declare (ignore c n server-secret))
            (destructuring-bind (c n client-secret client-public) client-entry
              (declare (ignore c n client-public))
              ;; compute the common key of the client and the entry
              (let ((common (frpc::dh-common-key client-secret server-public)))
                (make-xunion :success (frpc::dh-decrypt-conversation-key common 
                                                                         (concatenate '(vector (unsigned-byte 8))
                                                                                      key))))))
          (make-xunion :unknown nil)))))

(defrpc call-decrypt 3 cryptkeyarg cryptkeyres 
  (:program key-prog 1)
  (:arg-transformer (netname key)
    (list netname key))
  (:transformer (res)
    (if (eq (xunion-tag res) :success)
        (xunion-val res)
        (error 'key-error :stat (xunion-tag res))))
  (:documentation "X just sent me a message, decrypt the conversation key for me.")
  (:handler #'handle-decrypt))

;; ---------------------------------

(defun handle-gen (void)
  (declare (ignore void))
  (auth-or-fail)
  (frpc:des-conversation))

(defrpc call-gen 4 :void des-block 
  (:program key-prog 1)
  (:documentation "Generate a conversation key for me.")
  (:handler #'handle-gen))

;; ---------------------------------

;; don't support this yet
;;(defun handle-get (name)
;;  ;; lookup the unix creds for this netname string 
;;  (let ((creds (auth-or-fail)))
    
(defrpc call-get 5 netnamestr getcredres 
  (:program key-prog 1)
  (:arg-transformer (netname) netname)
  (:transformer (res)
    (if (eq (xunion-tag res) :success)
        (xunion-val res)
        (error 'key-error (xunion-tag res))))
  (:documentation "Get the UID, GID and GID-list for this netname."))

;; ----------------------------------------------
;; ----------------------------------------------

;; version 2

;;(defxtype* cryptkeyarg2 ()
;;  (:plist remotename netnamestr 
;;          remotekey netobj 
;;          deskey des-block))

;; (defxtype* key-netstarg ()
;;   (:plist st-priv-key keybuf 
;;           st-pub-key keybuf 
;;           st-netname netnamestr))

;; (defxunion key-netstres (keystatus) 
;;   (:key-success key-netstarg)
;;   (otherwise :void))



;; (defrpc call-null2 0 :void :void
;;   (:program key-prog 2))

;; (defrpc call-key-set 1 keybuf keystatus (:program key-prog 2))

;; (defrpc call-key-encrypt 2 cryptkeyarg cryptkeyres (:program key-prog 2))

;; (defrpc call-key-decrypt 3 cryptkeyarg cryptkeyres (:program key-prog 2))

;; (defrpc call-key-gen 4 :void des-block (:program key-prog 2))

;; (defrpc call-key-getcred 5 netnamestr getcredres (:program key-prog 2))

;; (defrpc call-key-encrypt-pk 6 cryptkeyarg2 cryptkeyres
;;              (:program key-prog 2))

;; (defrpc call-key-decrypt-pk 7 cryptkeyarg2 cryptkeyres
;;              (:program key-prog 2))

;; (defrpc call-key-net-put 8 key-netstarg keystatus (:program key-prog 2))

;; (defrpc call-key-net-get 9 :void key-netstres (:program key-prog 2))

;; (defrpc call-key-get-conv 10 keybuf cryptkeyres (:program key-prog 2))
